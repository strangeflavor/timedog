<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>//Swipe Control Variables
MouseX = 0;
MouseY = 0;
MouseXStart = 0;
MouseYStart = 0;
drag_x = 0;
drag_y = 0;

Swipe = false;
dragTime = 0;
dragDistance = 0; 
SwipeSpeed = 0;
released = false

PD = 0;  //Point of Direction

dragging = false;

snapTweenID = -1;
flyUFOID = -1;
ufoX = -1;
slider_position_xx = 0;

dx = 0;

view_xview[0] = currentWorld*vw;

view_xview_previous = view_xview[0];
view_xpos_normalized = 0;
dir=-1

objectAge = 0;
//currentWorld = 0;

savedCurrentWorld = false;
waitForUnlock = false;

pickupHUD = make(oPickup);
pickupHUD.image_xscale = scale;
pickupHUD.image_yscale = scale;
pickupHUD_x = view_xview[0]+vw - 100;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if !waitForUnlock {
    if mouse_check_button_pressed(mb_left) {
        //if snapTweenID &gt; -1 TweenDestroy(snapTweenID);
        //if TweenExists(snapTweenID) TweenStop(snapTweenID)
        dragging = true
        drag_x = mouse_x
        drag_y = mouse_y;
        dragTime = 0;
        SwipeSpeed = 0;
        //drag_y = mouse_y
    }
    
    if mouse_check_button_released(mb_left) {
        dragging = false;
        released = true;
        MouseX = mouse_x;
        MouseY = mouse_y;
    }
    
    if (dragging) {
        dragTime += 1;
        //dragDistance = point_distance(drag_x, drag_y, drag_x-mouse_x, drag_y);
        // actual dragging logic:
        view_xview[0] = view_xview[0] + (drag_x - mouse_x)*((1/scale)*.2);
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if !dragging {
    if released {
        PD = point_direction(drag_x, drag_y, MouseX, drag_y);
        Swipe = false;
        SwipeSpeed = dragDistance / dragTime;
        

        dragTime = 0;

        released = false;
    }
}

view_xview[0] = max(view_xview[0],-vw);
view_xview[0] = min(view_xview[0],vw*numWorlds);

/////////////////////////////////////////////
// snap to a world if not dragging
/////////////////////////////////////////////

var cx;
for (var i=0;i&lt;numWorlds;i+=1) {
    cx[i] = i*vw+vw/2;
}

var vx = view_xview[0]+vw/2;

if view_xview[0] &gt; view_xview_previous dir = -1;
if view_xview[0] &lt; view_xview_previous dir = 1;

dx = cx[numWorlds-1];

if !dragging and vx - vw/2 &gt; 0 and vx + vw/2 &lt; numWorlds*vw {

    // moving right
    if dir == -1 {
        for (i=0;i&lt;numWorlds-1;i+=1) if vx &gt;= cx[i] - vw*.67 and vx &lt; cx[i+1] - vw*.67 break;
        dx = cx[i];
    } else {
        for (i=numWorlds-1;i&gt;0;i-=1) if vx &lt;= cx[i] + vw*.67 and vx &gt; cx[i-1] + vw*.67 break;
        dx = cx[i];
    }

    currentWorld = i;
}

if !dragging {
    if vx - vw/2 &gt; 0 and vx + vw/2 &lt; numWorlds*vw {
        if !TweenExists(snapTweenID) snapTweenID = TweenFire(id, tween_xView, EaseLinear, TWEEN_MODE_ONCE, true, 0.0, .1, view_xview[0], dx - vw/2);
    } else {
        if view_xview[0] &lt; 0 {
            dx = cx[0];
            if !TweenExists(snapTweenID) snapTweenID = TweenFire(id, tween_xView, EaseLinear, TWEEN_MODE_ONCE, true, 0.0, .1, view_xview[0], dx - vw/2);
        } else {
            if view_xview[0] &gt; vw*(numWorlds-1) {
                dx = cx[numWorlds-1];
                if !TweenExists(snapTweenID) snapTweenID = TweenFire(id, tween_xView, EaseLinear, TWEEN_MODE_ONCE, true, 0.0, .1, view_xview[0], dx - vw/2);
            }
        }
    }
}

x = view_xview[0] + xstart;
y = view_yview[0] + ystart;

view_xpos_normalized = max(0,view_xview[0])/(vw*numWorlds);//(vw*numWorlds)/(view_xview[0]+vw/2);
/*
if waitForUnlock {
    background_color = merge_colour(c_red,make_color_rgb(64,127,255),abs(sin(objectAge*.01)));
} else {
    background_color = merge_colour(c_black,make_color_rgb(64,127,255),view_xpos_normalized);
}
*/
background_color = merge_colour(c_black,make_color_rgb(64,127,255),view_xpos_normalized);
view_xview_previous = view_xview[0];

objectAge += 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="75">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if debug == 1 {
    ///Draw Swipe Cursor
    draw_set_colour(c_orange);
    //draw_line(MouseXStart, MouseYStart, MouseX, MouseY);
    
    draw_set_colour(c_orange);
    draw_set_alpha(0.6);
    draw_rectangle(0, 0, 210, 75, 0);
    draw_set_alpha(1.0);
     
    //draw_set_font(fnt_Arial_B12);
    
    draw_set_halign(fa_left);
    draw_set_valign(fa_center);
    
    draw_set_colour(c_white);
    
    draw_text(8, 12, "Swipe Speed = " + string(SwipeSpeed));
    draw_text(8, 34, "Point Direction = " + string(PD));
    draw_text(8, 58, "xview  = " + string(view_xview[0]));
    draw_text(8, 80, "frac = " + string(frac(view_xview[0] / vw)));
    draw_text(8, 102, "dragtime = " + string(dragTime));
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
var surf_w = base_w;
var surf_h = base_h;

if !surface_exists(noisesurf) noisesurf = surface_create(surf_w,surf_h);
*/
var sliderWidth = vw;//room_width - 128;
var sliderHeight = 32*scale;
var yy = vh-80*scale;

draw_set_color(c_white);
draw_set_alpha(1);
draw_rectangle(x-sliderWidth,yy-sliderHeight,x+sliderWidth,yy+sliderHeight,false);

draw_set_color(background_color);
var cx,xx;
for (var i=0;i&lt;numWorlds;i+=1) {
    //xx = view_wview[0]*.0875+((i*view_wview[0])/(view_wview[0]*numWorlds)*(view_wview[0]*.9));
    xx = vw*.0875+((i*base_w*scale)/(base_w*numWorlds)*(base_w*.9));
    draw_circle(view_xview[0]+xx,yy,12*scale,false);
    //if i == currentWorld draw_sprite_ext(sUFO,0,xx,y,1,1,8*sin(objectAge*.05),c_white,1);
    if i == currentWorld slider_position_xx = xx;
}

if ufoX == -1 {
    ufoX = slider_position_xx;
} else {
    if ufoX != slider_position_xx {
        //if !TweenExists(flyUFOID) flyUFOID = TweenFire(id, tween_UFO, EaseLinear, TWEEN_MODE_ONCE, true, 0.0, .5, ufoX, slider_position_xx);
        if !TweenExists(flyUFOID) {
            ufoX_array[0] = 0;
            flyUFOID = TweenFire(id, "", EaseOutElastic, TWEEN_MODE_ONCE, true, 0.0, .4, ufoX, slider_position_xx);
        }

        ufoX = TweenCalc(flyUFOID);
    }
}

var flipUFO = -dir;
draw_sprite_ext(sUFO,0,view_xview[0]+ufoX,yy,flipUFO*scale,scale,8*sin(objectAge*.05),c_white,1);

// menu hud (world name, gem count)
draw_set_font(fStapler);
draw_set_color(c_white);
draw_set_halign(fa_left);
draw_set_valign(fa_top);

var _hudYO = 8*scale;

draw_text_ext_transformed(view_xview[0]+16*scale,_hudYO+4*scale,'WORLD '+string(currentWorld+1)+'#'+worldNames[currentWorld],24,-1,scale,scale,0);

var sw = string_width('x'+string(gems));

draw_set_halign(fa_right);
draw_text_ext_transformed(view_xview[0]+vw-16*scale,_hudYO+12*scale,'x '+string(gems),0,-1,scale,scale,0);

pickupHUD.x = view_xview[0]+vw-sw*scale-40*scale;
pickupHUD.y = _hudYO+20*scale; //pickupHUD_y*scale;

/*
pickupHUD.x = pickupHUD_x + view_xview[0];
pickupHUD.y = pickupHUD_y;
draw_text(pickupHUD_x+view_xview[0]+16,42,'x'+string(gems));
*/
//draw_text(view_wview[0]-16,16,
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
